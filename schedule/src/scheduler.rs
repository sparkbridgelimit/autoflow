use actix::prelude::*;
use actix::Actor;
use chrono::Utc;
use std::collections::{BinaryHeap, HashSet};
use std::time::Duration;

use crate::task::Task;

/// Executor trait for handling task execution
pub trait Executor: Send + Sync + 'static {
    fn execute(&self, task: &Task);
}

/// Scheduler struct responsible for executing tasks.
pub struct Scheduler<E: Executor> {
    /// BinaryHeap of scheduled tasks, ordered by run time.
    pub tasks: BinaryHeap<Task>,

    /// A set of unique task identifiers to prevent duplicate tasks in the same time window.
    unique_task_ids: HashSet<String>,

    /// Executor trait for handling task execution
    executor: E,
}

impl<E: Executor> Scheduler<E> {
    pub fn new(executor: E) -> Self {
        Self {
            tasks: BinaryHeap::new(),
            unique_task_ids: HashSet::new(),
            executor,
        }
    }

    /// Adds tasks generated by the `Planner` to the scheduler's task heap, ensuring idempotency.
    ///
    /// # Arguments
    ///
    /// * `tasks` - A vector of `Task` objects generated by the `Planner`.
    pub fn add_tasks(&mut self, tasks: Vec<Task>) {
        for task in tasks {
            let task_id = format!("{}-{}", task.trigger_id, task.run_at.timestamp_millis());

            // Ensure idempotency: add only if the task is not already in the unique set
            if self.unique_task_ids.contains(&task_id) {
                println!("Task {} already scheduled, skipping.", task_id);
                continue;
            }

            // Add task to the heap and record its unique ID
            self.tasks.push(task);
            self.unique_task_ids.insert(task_id);
        }

        // After adding tasks, run the scheduler to check if any task is ready to execute
        self.run();
    }
}

impl<E: Executor> Scheduler<E> {
    /// Checks if the next task is ready to execute and runs it if so.
    pub fn run(&mut self) {
        while let Some(task) = self.tasks.peek() {
            // If the task is ready to run, execute it
            if task.run_at <= Utc::now() {
                let task = self.tasks.pop().unwrap();
                self.executor.execute(&task);
            } else {
                // If the next task is not ready, exit the loop
                break;
            }
        }
    }
}

/// Actix actor implementation for Scheduler.
impl<E: Executor + std::marker::Unpin> Actor for Scheduler<E> {
    type Context = Context<Self>;

    /// Starts the Tick message loop with a fixed interval.
    fn started(&mut self, ctx: &mut Self::Context) {
        ctx.run_interval(Duration::from_secs(1), |scheduler, _ctx| {
            scheduler.run();
        });
    }
}

/// Message type for adding new tasks to the Scheduler.
pub struct AddTasks(pub Vec<Task>);

/// Implement `Message` trait for `AddTasks` with a `Result` type of `()`.
impl Message for AddTasks {
    type Result = ();
}

/// Handler for `AddTasks` message to add new tasks to the scheduler.
impl<E: Executor + std::marker::Unpin> Handler<AddTasks> for Scheduler<E> {
    type Result = ();

    fn handle(&mut self, msg: AddTasks, _ctx: &mut Self::Context) {
        self.add_tasks(msg.0); // Use the `add_tasks` method to add tasks from the message
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Utc;
    use std::sync::{Arc, Mutex};
    use std::time::Duration;

    /// LogExecutor 记录每次执行的任务 ID
    struct LogExecutor {
        log: Arc<Mutex<Vec<String>>>,
    }

    impl LogExecutor {
        fn new() -> Self {
            LogExecutor {
                log: Arc::new(Mutex::new(Vec::new())),
            }
        }

        fn get_log(&self) -> Vec<String> {
            self.log.lock().unwrap().clone()
        }
    }

    impl Executor for LogExecutor {
        fn execute(&self, task: &Task) {
            let mut log = self.log.lock().unwrap();
            log.push(task.id.clone());
            println!("Executing Task ID: {}", task.id);
        }
    }

    #[actix_rt::test]
    async fn test_empty_queue() {
        let executor = LogExecutor::new();
        let log = executor.log.clone();
        let _scheduler = Scheduler::new(executor).start();

        // 等待 1 秒，验证空队列不应执行任何任务
        actix::clock::sleep(Duration::from_secs(1)).await;

        // 检查日志应为空
        let log_entries = log.lock().unwrap();
        assert!(
            log_entries.is_empty(),
            "No tasks should be executed for an empty queue."
        );
    }

    #[actix_rt::test]
    async fn test_immediate_execution() {
        let executor = LogExecutor::new();
        let log = executor.log.clone();
        let scheduler = Scheduler::new(executor).start();

        let now = Utc::now();
        let tasks = vec![Task::new("task_immediate", now, "workflow1", "trigger1")];

        scheduler.do_send(AddTasks(tasks));

        // 等待 1 秒确保任务执行
        actix::clock::sleep(Duration::from_secs(1)).await;

        // 检查日志，验证任务立即执行
        let log_entries = log.lock().unwrap();
        assert_eq!(log_entries.len(), 1);
        assert_eq!(log_entries[0], "task_immediate");
    }

    #[actix_rt::test]
    async fn test_add_tasks_and_run() {
        let executor = LogExecutor::new();
        let log = executor.log.clone();
        let scheduler = Scheduler::new(executor).start();

        let now = Utc::now();
        let tasks = vec![
            Task::new(
                "task1",
                now + Duration::from_secs(1),
                "workflow1",
                "trigger1",
            ),
            Task::new(
                "task2",
                now + Duration::from_secs(2),
                "workflow2",
                "trigger2",
            ),
            Task::new(
                "task1",
                now + Duration::from_secs(1),
                "workflow1",
                "trigger1",
            ), // Duplicate task for idempotency
        ];

        scheduler.do_send(AddTasks(tasks));

        // 等待 3 秒，确保所有任务有时间执行
        actix::clock::sleep(Duration::from_secs(3)).await;

        // 检查日志，验证仅唯一任务被执行
        let log_entries = log.lock().unwrap();
        assert_eq!(log_entries.len(), 2);
        assert!(log_entries.contains(&"task1".to_string()));
        assert!(log_entries.contains(&"task2".to_string()));
    }

    #[actix_rt::test]
    async fn test_future_task_not_executed_early() {
        let executor = LogExecutor::new();
        let log = executor.log.clone();
        let scheduler = Scheduler::new(executor).start();

        let now = Utc::now();
        let tasks = vec![Task::new(
            "task_future",
            now + Duration::from_secs(10),
            "workflow1",
            "trigger1",
        )];

        scheduler.do_send(AddTasks(tasks));

        // 等待 5 秒，不应执行未来任务
        actix::clock::sleep(Duration::from_secs(5)).await;

        // 检查日志，确保任务未提前执行
        let log_entries = log.lock().unwrap();
        assert!(
            log_entries.is_empty(),
            "Future tasks should not execute before their scheduled time."
        );
    }

    #[actix_rt::test]
    async fn test_high_frequency_scheduling() {
        let executor = LogExecutor::new();
        let log = executor.log.clone();
        let scheduler = Scheduler::new(executor).start();

        let now = Utc::now();
        let mut tasks = vec![];

        for i in 0..10 {
            let task_id = format!("task_{}", i);
            tasks.push(Task::new(
                &task_id,
                now + Duration::from_millis(i * 100),
                "workflow1",
                "trigger1",
            ));
        }

        scheduler.do_send(AddTasks(tasks));

        // 等待 2 秒，确保所有任务有时间执行
        actix::clock::sleep(Duration::from_secs(2)).await;

        // 检查日志，确保所有任务按顺序执行
        let log_entries = log.lock().unwrap();
        assert_eq!(log_entries.len(), 10);
        for i in 0..10 {
            assert_eq!(log_entries[i], format!("task_{}", i));
        }
    }

    #[actix_rt::test]
    async fn test_duplicate_task_handling() {
        let executor = LogExecutor::new();
        let log = executor.log.clone();
        let scheduler = Scheduler::new(executor).start();

        let now = Utc::now();
        let tasks = vec![
            Task::new(
                "task1",
                now + Duration::from_secs(1),
                "workflow1",
                "trigger1",
            ),
            Task::new(
                "task1",
                now + Duration::from_secs(1),
                "workflow1",
                "trigger1",
            ), // Duplicate task
            Task::new(
                "task2",
                now + Duration::from_secs(1),
                "workflow2",
                "trigger2",
            ),
        ];

        scheduler.do_send(AddTasks(tasks));

        // 等待 3 秒，确保所有任务有时间执行
        actix::clock::sleep(Duration::from_secs(3)).await;

        // 检查日志，验证仅唯一任务被执行
        let log_entries = log.lock().unwrap();
        assert_eq!(log_entries.len(), 2);
        assert!(log_entries.contains(&"task1".to_string()));
        assert!(log_entries.contains(&"task2".to_string()));
    }

    #[actix_rt::test]
    async fn test_task_execution_order() {
        let executor = LogExecutor::new();
        let log = executor.log.clone();
        let scheduler = Scheduler::new(executor).start();

        let now = Utc::now();
        let tasks = vec![
            Task::new(
                "task1",
                now + Duration::from_secs(2),
                "workflow1",
                "trigger1",
            ),
            Task::new(
                "task2",
                now + Duration::from_secs(1),
                "workflow2",
                "trigger2",
            ),
            Task::new(
                "task3",
                now + Duration::from_secs(3),
                "workflow3",
                "trigger3",
            ),
        ];

        scheduler.do_send(AddTasks(tasks));

        // 等待 4 秒以确保任务按顺序执行
        actix::clock::sleep(Duration::from_secs(4)).await;

        let log_entries = log.lock().unwrap();
        assert_eq!(
            *log_entries,
            vec![
                "task2".to_string(),
                "task1".to_string(),
                "task3".to_string()
            ]
        );
    }
}
